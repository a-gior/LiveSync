import {
  Disposable,
  Webview,
  WebviewPanel,
  window,
  Uri,
  ViewColumn,
  workspace,
  ConfigurationTarget,
  ExtensionContext,
} from "vscode";
import { Panel } from "./Panel";

import { ConfigurationMessage } from "@shared/DTOs/messages/configurationDTO";
import { ConfigurationState } from "@shared/DTOs/states/configurationState";
import { Client } from "ssh2";
import { SFTPClient } from "../services/SFTPClient";

export class ConfigurationPanel extends Panel {
  static render(extensionUri: Uri) {
    const viewType = "configurationViewType";
    const title = "Configuration";
    const localResourceRoots = [
      Uri.joinPath(extensionUri, "out"),
      Uri.joinPath(extensionUri, "webview-ui/public/build"),
    ];
    const configurationCallback = (message: ConfigurationMessage) => {
      switch (message.command) {
        case "updateConfiguration":
          console.log("UpdateConfiguration...");
          this.updateConfiguration(message.configuration);
          break;
        case "testConnection":
          console.log("TestConnection...");
          this.testConnection(message.configuration);
          break;
      }
    };
    const filepaths = [
      "webview-ui/public/build/media/reset.css",
      "webview-ui/public/build/media/vscode.css",
      "webview-ui/public/build/pages/configuration/configuration.css", // generated by compiling svelte with rollup
      "webview-ui/public/build/pages/configuration/configuration.js", // generated by compiling svelte with rollup
    ];

    // Call the render method from the parent class with additional parameters
    super.render(
      extensionUri,
      viewType,
      title,
      localResourceRoots,
      filepaths,
      configurationCallback,
      // Additional options if needed
    );

    const workspaceConfig = this.getWorkspaceConfiguration();
    if (workspaceConfig !== null) {
      const configurationMessage = {
        command: "setInitialConfiguration",
        configuration: workspaceConfig["config"],
      };

      this.currentPanel?.getPanel().webview.postMessage(configurationMessage);
    }
  }

  static updateConfiguration(
    configuration: ConfigurationMessage["configuration"],
  ) {
    const config = workspace.getConfiguration("LiveSync");
    const { hostname, port, username, authMethod, password, sshKey } =
      configuration;

    config.update("hostname", hostname, ConfigurationTarget.Workspace);
    config.update("port", port, ConfigurationTarget.Workspace);
    config.update("username", username, ConfigurationTarget.Workspace);
    config.update("authMethod", authMethod, ConfigurationTarget.Workspace);
    config.update("password", password, ConfigurationTarget.Workspace);
    config.update("sshKey", sshKey, ConfigurationTarget.Workspace);
  }

  static async testConnection(
    configuration: ConfigurationMessage["configuration"],
  ): Promise<void> {
    // Function to connect via SSH
    function connectSSH(config: ConfigurationMessage["configuration"]): void {
      const conn = new Client();

      conn.on("ready", () => {
        console.log("SSH Connection successful");
        conn.end();
      });
      conn.on("error", (err) => {
        console.error("Error connecting via SSH:", err);
      });
      conn.connect(config);
    }

    const { hostname, port, username, password } = configuration;
    // Test SSH connection
    // connectSSH(configuration);

    // Test SFTP connection
    //* Open the connection
    const client = new SFTPClient();
    console.log("SFTP Client with config: ", configuration);
    await client.connect(configuration);

    const clientErrors = client.getErrors();
    if (clientErrors.length > 0) {
      window.showErrorMessage(clientErrors[0].error.message);
    } else {
      window.showInformationMessage("Test Connection successful");
    }

    // //* List working directory files
    // await client.listFiles(".");

    // //* Upload local file to remote file
    // await client.uploadFile("./local.txt", "./remote.txt");

    // //* Download remote file to local file
    // await client.downloadFile("./remote.txt", "./download.txt");

    // //* Delete remote file
    // await client.deleteFile("./remote.txt");

    //* Close the connection
    await client.disconnect();
  }

  static getWorkspaceConfiguration(): ConfigurationState | null {
    const config = workspace.getConfiguration("LiveSync");

    // Get individual configuration values
    const hostname = config.get<string>("hostname");
    const port = config.get<number>("port");
    const username = config.get<string>("username");
    const authMethod = config.get<string | undefined>("authMethod");
    const password = config.get<string>("password");
    const sshKeyFilePath = config.get<string | null>("sshKey");

    // Return null if any value is empty or undefined
    if (
      !hostname ||
      !port ||
      !username ||
      !authMethod ||
      !password ||
      !sshKeyFilePath
    ) {
      return null;
    }

    // Construct the workspace configuration object
    const workspaceConfig: ConfigurationState = {
      config: {
        hostname: hostname,
        port: port,
        username: username,
        authMethod: authMethod,
        password: password,
        sshKey: sshKeyFilePath,
      },
    };

    console.log("getWorkspaceConfiguration", workspaceConfig);
    return workspaceConfig;
  }
}
