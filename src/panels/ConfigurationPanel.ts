import { Uri, WorkspaceFolder, commands } from "vscode";
import { Panel } from "./Panel";

import { SFTPClient } from "../services/SFTPClient";
import { FullConfigurationMessage } from "@shared/DTOs/messages/FullConfigurationMessage";
import { FileEventActionsMessage } from "@shared/DTOs/messages/FileEventActionsMessage";
import { ConnectionManager } from "../managers/ConnectionManager";
import { IgnoreListMessage } from "@shared/DTOs/messages/IgnoreListMessage";
import { WorkspaceConfigManager } from "../managers/WorkspaceConfigManager";
import { LOG_FLAGS, logErrorMessage, logInfoMessage } from "../managers/LogManager";
import { ConfigurationState } from "@shared/DTOs/states/ConfigurationState";
import { WorkspaceConfig, WorkspaceConfigManager2 } from "../managers/WorkspaceConfigManager2";
import { configManager } from "../extension";

export class ConfigurationPanel extends Panel {
  static show(extensionUri: Uri, folder: WorkspaceFolder | null = null) {
    const viewType = "configurationViewType";
    const title = "LiveSync Configuration";
    const localResourceRoots = [
      Uri.joinPath(extensionUri, "out"),
      Uri.joinPath(extensionUri, "resources"),
      Uri.joinPath(extensionUri, "webview-ui/public/build")
    ];
    const configurationCallback = async (message: FullConfigurationMessage) => {
      switch (message.command) {
        case "updateConfiguration":
          await this.updateConfiguration(message);
          break;
        case "testConnection":
          if (message.configuration) {
            const result = await commands.executeCommand("livesync.testConnection", message.configuration);
            if (result) {
              logInfoMessage("Connection successful.", LOG_FLAGS.ALL);
            } else {
              logErrorMessage("Connection failed. Please check the configuration.", LOG_FLAGS.ALL);
            }
          }
          break;
        case "loadConfig": 
          if(message.selectedFolder) {
            const config = configManager?.getConfig(message.selectedFolder.uri);
            const configMessage: FullConfigurationMessage = {
              command: "setInitialConfiguration",
              ...config,
              workspaceFolders: WorkspaceConfigManager2.getFolders()
            };
            this.currentPanel?.getPanel().webview.postMessage(configMessage);
          }
          break;
      }
    };

    const filepaths = [
      "resources/css/reset.css",
      "resources/css/vscode.css",
      "webview-ui/public/build/pages/configuration/configuration.css", // generated by compiling svelte with rollup
      "webview-ui/public/build/pages/configuration/configuration.js" // generated by compiling svelte with rollup
    ];

    // Call the render method from the parent class with additional parameters
    super.render(
      extensionUri,
      viewType,
      title,
      localResourceRoots,
      filepaths,
      configurationCallback
      // Additional options if needed
    );

    const configMessage: FullConfigurationMessage = {
      command: "setInitialConfiguration",
      ...WorkspaceConfigManager.getWorkspaceConfiguration(),
      workspaceFolders: WorkspaceConfigManager2.getFolders(),
      ...(folder ? { selectedFolder: folder } : {})
    };
    this.currentPanel?.getPanel().webview.postMessage(configMessage);
  }

  static async saveRemotePath(remotePath: string) {
    const configuration = WorkspaceConfigManager.getRemoteServerConfigured();

    const connectionManager = await ConnectionManager.getInstance(configuration);
    connectionManager
      .doSFTPOperation(async (sftpClient: SFTPClient) => {
        if (!(await sftpClient.exists(remotePath))) {
          logErrorMessage(`Remote path ${remotePath} does not exist`, LOG_FLAGS.ALL);
        }
      }, "Saving Remote path")
      .then(async () => {
        // All good so we update the remote path config
        await WorkspaceConfigManager.update("remotePath", remotePath);
      });
  }

  static async saveFileEventActions(actions: FileEventActionsMessage["actions"]) {
    try {
      await WorkspaceConfigManager.batchUpdate({
        actionOnUpload: actions.actionOnUpload,
        actionOnDownload: actions.actionOnDownload,
        actionOnSave: actions.actionOnSave,
        actionOnCreate: actions.actionOnCreate,
        actionOnDelete: actions.actionOnDelete,
        actionOnMove: actions.actionOnMove,
        actionOnOpen: actions.actionOnOpen
      });
    } catch (error) {
      logErrorMessage("Error saving file event actions", LOG_FLAGS.ALL, error);
    }
  }

  static async saveRemoteServerConfiguration(configuration: ConfigurationState["configuration"]): Promise<void> {
    try {
      if (configuration) {
        const testResult = await commands.executeCommand("livesync.testConnection", configuration);
        if (!testResult) {
          throw new Error("Connection test failed. Please check the configuration.");
        }

        const { hostname, port, username, password, privateKeyPath, passphrase } = configuration;

        await WorkspaceConfigManager.batchUpdate({
          hostname,
          port,
          username,
          password,
          privateKeyPath,
          passphrase
        });
      } else {
        throw new Error("Invalid configuration");
      }
    } catch (error: any) {
      logErrorMessage(`Couldn't save configuration: ${error.message}`, LOG_FLAGS.ALL);
    }
  }

  static async saveIgnoreList(ignoreList: IgnoreListMessage["ignoreList"]) {
    try {
      await WorkspaceConfigManager.update("ignoreList", ignoreList);
    } catch (error) {
      logErrorMessage("Error saving ignore list", LOG_FLAGS.ALL, error);
    }
  }

  static async updateConfiguration(configuration: FullConfigurationMessage) {
    if (configuration.configuration) {
      await this.saveRemoteServerConfiguration(configuration.configuration);
    }
    if (configuration.remotePath) {
      await this.saveRemotePath(configuration.remotePath);
    }
    if (configuration.fileEventActions) {
      await this.saveFileEventActions(configuration.fileEventActions);
    }
    if (configuration.ignoreList) {
      await this.saveIgnoreList(configuration.ignoreList);
    }
  }
}
